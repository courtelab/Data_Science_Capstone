---
title: "MovieLens Project"
author: "Courtellemont Remi"
date: "`r format(Sys.Date())`"
output:
  github_document: default
editor_options: 
  markdown: 
    wrap: sentence
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## EXECUTIVE SUMMARY

The goal is to create a movie recommendation system using the MovieLens Dataset <https://grouplens.org/datasets/movielens/10m/>.  
the train and validation sets are provided within the course in www.edx.org.

We develop our algorithm using the edx set.  
For a final test of our final algorithm, we predict movie ratings in the validation set (the final hold-out test set) as if they were unknown.  
RMSE will be used to evaluate how close our predictions are to the true values in the validation set (the final hold-out test set).

```{r libraries and RMSE, message=FALSE, warning=FALSE}
library(tidyverse)
library(lubridate)
library(caret)
RMSE <- function(true_ratings, predicted_ratings){
  sqrt(mean((true_ratings - predicted_ratings)^2))
}
```

The first step will be to clean and transform if necessary the data.  
The second step will be to build the model with the training set.  
The third step will be to apply regularization.  
The fourth step will be to apply the model to the validation set and check the RMSE result.

## METHOD AND ANALYSIS

### INITIATION

The initial script comes from EDX course, and it creates edx and validation sets.

```{r data from course, include=FALSE}
setwd("C:/Users/H13456/Documents/R projects/Data_Science_Capstone")
source(file = "edx_file.R")
```

In order to avoid modifying the original data, the files are renamed:

```{r data renamed, warning = FALSE}
train_set <- edx
test_set <- validation
```

### DATA EXPLORATION

#### General

The first 5 lines of train_set :

```{r 5 first lines, warning=FALSE}
head(train_set, 5) %>% knitr::kable(align = 'c')
```

The *output* we want to predict/estimate is the **rating** variable.

The train_set has the following dimensions:

```{r dimensions, warning=FALSE}
dim(train_set) %>% knitr::kable(align = 'c')
```

The *variable* names :

```{r variables, warning=FALSE}
colnames(train_set) %>% knitr::kable(align = 'c')
```

We identify 3 main *predictors*: **MovieId**, **userId** and **genres**.  
It is easy to understand that they are impacting the *rating*.

The number of unique *predictors* in the data set :

```{r number of movies, warning=FALSE}
table_data <- data.frame(variable = c("movies", "users", "genres"),
                         unique_numbers = c(n_distinct(train_set$movieId),
                                    n_distinct(train_set$userId),
                                    n_distinct(train_set$genres)))
table_data %>% knitr::kable(align = 'c')
```

The 5 most rated movies in the data set :

```{r the 5 most rated movies, message = FALSE, warning=FALSE}
train_set %>% group_by(movieId, title) %>%
	summarize(count = n()) %>%
	arrange(desc(count)) %>%
  head(5) %>%
  knitr::kable(align = 'c')
```

...and the 5 least rated movies in the data set :

```{r the 5 least rated movies, message = FALSE, warning=FALSE}
train_set %>% group_by(movieId, title) %>%
	summarize(count = n()) %>%
	arrange(desc(count)) %>%
  tail(5) %>%
  knitr::kable(align = 'c')
```

#### Time predictor

The data base include a **timestamp**, which corresponds to the date of rating.  
It can be converted into rating date's year, with a new column called **ratingDate** :

```{r timestamp, warning = FALSE}
train_set %>%
  select(timestamp, title) %>%
  mutate(ratingDate = as.integer(year(as_datetime(timestamp)))) %>%
  head(5) %>%
  knitr::kable(align = 'c')
```

In the title of the movie, we can see the date of release of the movie.  
We can extract this year, and create a new column called **movieDate**.

```{r movieDate, warning = FALSE}
train_set %>%
  select(timestamp, title) %>%
  mutate(ratingDate = as.integer(year(as_datetime(timestamp)))) %>%
  mutate(movieDate = as.integer(str_sub(title, -5, -2))) %>%
  head(5) %>%
  knitr::kable(align = 'c')
```

It can be interesting to have a *predictor* based on time difference between the year of the rating and the year of the movie.  
It is easy to understand that if a movie has been released long time ago, it might has less impact on the user, compare to a movie just released.  
We call this new column **ratingPeriod**.

```{r ratingPeriod, warning=FALSE}
train_set %>%
  select(timestamp, title) %>%
  mutate(ratingDate = as.integer(year(as_datetime(timestamp)))) %>%
  mutate(movieDate = as.integer(str_sub(title, -5, -2))) %>%
  mutate(ratingPeriod = ratingDate - movieDate) %>%
  head(5) %>%
  knitr::kable(align = 'c')
```

An issue is that the **ratingPeriod** is sometimes negative, which in practice is not possible.

```{r ratingPeriod negative, warning = FALSE}
train_set %>%
  select(timestamp, title) %>%
  mutate(ratingDate = as.integer(year(as_datetime(timestamp)))) %>%
  mutate(movieDate = as.integer(str_sub(title, -5, -2))) %>%
  mutate(ratingPeriod = ratingDate - movieDate) %>%
  group_by(ratingPeriod) %>%
  arrange(ratingPeriod) %>%
  summarize(n = n()) %>%
  filter(ratingPeriod <= 0) %>%
  knitr::kable(align = 'c')
```

In order to avoid this situation, we modify the **ratingPeriod** to 0 when negative.

```{r avoid negative ratingPeriod, warning=FALSE}
train_set %>%
  select(timestamp, title) %>%
  mutate(ratingDate = as.integer(year(as_datetime(timestamp)))) %>%
  mutate(movieDate = as.integer(str_sub(title, -5, -2))) %>%
  mutate(ratingPeriod = ratingDate - movieDate) %>%
  mutate(ratingPeriod = ifelse(ratingPeriod < 0, 0, ratingPeriod)) %>%
  group_by(ratingPeriod) %>%
  arrange(ratingPeriod) %>%
  summarize(n = n()) %>%
  knitr::kable(align = 'c')
```

The train_set and test_set are entirely modified to add the **ratingPeriod** column.

```{r train_set and test_set time modification, warning = FALSE}
train_set <- train_set %>%
  mutate(ratingDate = as.integer(year(as_datetime(timestamp)))) %>%
  mutate(movieDate = as.integer(str_sub(title, -5, -2))) %>%
  mutate(ratingPeriod = ratingDate - movieDate) %>%
  mutate(ratingPeriod = ifelse(ratingPeriod < 0, 0, ratingPeriod))

test_set <- test_set %>%
  mutate(ratingDate = as.integer(year(as_datetime(timestamp)))) %>%
  mutate(movieDate = as.integer(str_sub(title, -5, -2))) %>% 
  mutate(ratingPeriod = ratingDate - movieDate) %>%
  mutate(ratingPeriod = ifelse(ratingPeriod < 0, 0, ratingPeriod))

```

### MODELING

Due to the number of movies and users, training the data set is not feasible.  
Then we will build the model, according to the following formula:  
$$Y_{u,i,t,g} = \mu + b_i + b_u + b_t + b_g + \varepsilon_{u,i,t,g}$$

Where:  
$Y_{u,i,t,g}$ represents the estimated value.
$\mu$ represents the mean  
$b_i$ represents the movie effect  
$b_u$ represents the user effect  
$b_t$ represents the time effect  
$b_g$ represents the gender effect

And then we will apply regularization by creating a partition on the train_set.

## RESULTS

### BUILDING THE MODEL WITH THE TRAINING SET

#### THE NAIVE MODEL

We build a naive model where all movies are rated the average $\mu$.   
We calculate the average of the train_set and then the RMSE of the test_set (validation set).  
```{r naive model, message=FALSE, warning=FALSE}
mu <- mean(train_set$rating) # building the naive model
train_set <- train_set %>%
  mutate(mu = mu)
predicted_ratings <- mu  # calculating the prediction on the test set
naive_rmse <- RMSE(test_set$rating, predicted_ratings) # calculating the loss function with the test set
rmse_results <- data.frame(method = "Just the Average Model", RMSE = naive_rmse, target_RMSE = " < 0.86490")  # making a summary table
rmse_results %>%
  knitr::kable(align = 'c')
```

We see that the RMSE is far from the target.



