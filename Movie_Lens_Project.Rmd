---
title: "MovieLens Project"
author: "Courtellemont Remi"
date: "`r format(Sys.Date())`"
output:
  github_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## EXECUTIVE SUMMARY

The goal is to create a movie recommendation system using the MovieLens Dataset https://grouplens.org/datasets/movielens/10m/.
the train and validation sets are provided within the course in www.edx.org.

We develop our algorithm using the edx set.
For a final test of our final algorithm, we predict movie ratings in the validation set (the final hold-out test set) as if they were unknown.
RMSE will be used to evaluate how close our predictions are to the true values in the validation set (the final hold-out test set).

```{r libraries and RMSE, message=FALSE, warning=FALSE}
library(tidyverse)
library(lubridate)
library(caret)
RMSE <- function(true_ratings, predicted_ratings){
  sqrt(mean((true_ratings - predicted_ratings)^2))
}
```

The first step will be to clean and complete the edx set.
The second step will be to build the model and apply it to edx set.
The third step will be to apply regularization.
The fourth step will be to check the RMSE result of the validation set.


## METHOD AND ANALYSIS

### INITIATION

script from www.edx.org course, in order to create edx and validation sets :
```{r data from course, message=FALSE, warning=FALSE, include=FALSE}
##########################################################
# Create edx set, validation set (final hold-out test set)
##########################################################

# Note: this process could take a couple of minutes

if(!require(tidyverse)) install.packages("tidyverse", repos = "http://cran.us.r-project.org")
if(!require(caret)) install.packages("caret", repos = "http://cran.us.r-project.org")
if(!require(data.table)) install.packages("data.table", repos = "http://cran.us.r-project.org")

library(tidyverse)
library(caret)
library(data.table)

# MovieLens 10M dataset:
# https://grouplens.org/datasets/movielens/10m/
# http://files.grouplens.org/datasets/movielens/ml-10m.zip

dl <- tempfile()
download.file("https://files.grouplens.org/datasets/movielens/ml-10m.zip", dl)

ratings <- fread(text = gsub("::", "\t", readLines(unzip(dl, "ml-10M100K/ratings.dat"))),
                 col.names = c("userId", "movieId", "rating", "timestamp"))

movies <- str_split_fixed(readLines(unzip(dl, "ml-10M100K/movies.dat")), "\\::", 3)
colnames(movies) <- c("movieId", "title", "genres")

# if using R 4.0 or later:
movies <- as.data.frame(movies) %>% mutate(movieId = as.numeric(movieId),
                                           title = as.character(title),
                                           genres = as.character(genres))


movielens <- left_join(ratings, movies, by = "movieId")

# Validation set will be 10% of MovieLens data
set.seed(1, sample.kind="Rounding") # if using R 3.5 or earlier, use `set.seed(1)`
test_index <- createDataPartition(y = movielens$rating, times = 1, p = 0.1, list = FALSE)
edx <- movielens[-test_index,]
temp <- movielens[test_index,]

# Make sure userId and movieId in validation set are also in edx set
validation <- temp %>% 
  semi_join(edx, by = "movieId") %>%
  semi_join(edx, by = "userId")

# Add rows removed from validation set back into edx set
removed <- anti_join(temp, validation)
edx <- rbind(edx, removed)

rm(dl, ratings, movies, test_index, temp, movielens, removed)
```

### DATA EXPLORATION

#### General

The first 5 lines of edx set :
```{r general, warning=FALSE}
head(edx, 5) %>% knitr::kable(align = 'c')
```

The *output* we want to predict/estimate is the **rating** variable.

The edx data set has the following dimensions:
```{r dimensions, warning=FALSE}
dim(edx) %>% knitr::kable(align = 'c')
```

The *variable* names :
```{r variables, warning=FALSE}
colnames(edx) %>% knitr::kable(align = 'c')
```

We identify 3 main *predictors*: **MovieId**, **userId** and **genres**.
It is easy to understand that they are impacting the *rating*.

The number of unique *predictors* in the data set :
```{r number of movies, warning=FALSE}
table_data <- data.frame(variable = c("movies", "users", "genres"),
                         unique_numbers = c(n_distinct(edx$movieId),
                                    n_distinct(edx$userId),
                                    n_distinct(edx$genres)))
table_data %>% knitr::kable(align = 'c')
```

The 5 most rated movies in the data set :
```{r the 5 most rated movies, warning=FALSE}
edx %>% group_by(movieId, title) %>%
	summarize(count = n()) %>%
	arrange(desc(count)) %>%
  head(5) %>%
  knitr::kable(align = 'c')
```

...and the 5 least rated movies in the data set :
```{r the 5 least rated movies, warning=FALSE}
edx %>% group_by(movieId, title) %>%
	summarize(count = n()) %>%
	arrange(desc(count)) %>%
  tail(5) %>%
  knitr::kable(align = 'c')
```

#### Time predictor

The data base include a **timestamp**, which corresponds to the date of rating.
It can be converted into rating date's year, with a new column called **ratingDate** :
```{r timestamp, warning = FALSE}
edx %>%
  select(timestamp, title) %>%
  mutate(ratingDate = as.integer(year(as_datetime(timestamp)))) %>%
  head(5) %>%
  knitr::kable(align = 'c')
```

In the title of the movie, we can see the date of release of the movie.
We can extract this year, and create a new column called **movieDate**.
```{r movieDate, warning = FALSE}
edx %>%
  select(timestamp, title) %>%
  mutate(ratingDate = as.integer(year(as_datetime(timestamp)))) %>%
  mutate(movieDate = as.integer(str_sub(title, -5, -2))) %>%
  head(5) %>%
  knitr::kable(align = 'c')
```

It can be interesting to have a *predictor* based on time difference between the year of the rating and the year of the movie. It is easy to understand that if a movie has been released long time ago, it might has less impact on the user, compare to a movie just released.
We call this new column **ratingPeriod**.
```{r ratingPeriod, warning=FALSE}
edx %>%
  select(timestamp, title) %>%
  mutate(ratingDate = as.integer(year(as_datetime(timestamp)))) %>%
  mutate(movieDate = as.integer(str_sub(title, -5, -2))) %>%
  mutate(ratingPeriod = ratingDate - movieDate) %>%
  head(5) %>%
  knitr::kable(align = 'c')
```

An issue is that the **ratingPeriod** is sometimes negative, which in practice is not possible.
```{r ratingPeriod negative, warning = FALSE}
edx %>%
  select(timestamp, title) %>%
  mutate(ratingDate = as.integer(year(as_datetime(timestamp)))) %>%
  mutate(movieDate = as.integer(str_sub(title, -5, -2))) %>%
  mutate(ratingPeriod = ratingDate - movieDate) %>%
  group_by(ratingPeriod) %>%
  arrange(ratingPeriod) %>%
  summarize(n = n()) %>%
  knitr::kable(align = 'c')
```

In order to avoid this situation, we modify the **ratingPeriod** to 0 when negative.
```{r avoid negative ratingPeriod, warning=FALSE}
edx %>%
  select(timestamp, title) %>%
  mutate(ratingDate = as.integer(year(as_datetime(timestamp)))) %>%
  mutate(movieDate = as.integer(str_sub(title, -5, -2))) %>%
  mutate(ratingPeriod = ratingDate - movieDate) %>%
  mutate(ratingPeriod = ifelse(ratingPeriod < 0, 0, ratingPeriod)) %>%
  group_by(ratingPeriod) %>%
  arrange(ratingPeriod) %>%
  summarize(n = n()) %>%
  knitr::kable(align = 'c')
```

The edx and validation sets are entirely modified to add the **ratingPeriod** column.
```{r edx and validation time modification, warning = FALSE}
edx <- edx %>%
  mutate(ratingDate = as.integer(year(as_datetime(timestamp)))) %>%
  mutate(movieDate = as.integer(str_sub(title, -5, -2))) %>%
  mutate(ratingPeriod = ratingDate - movieDate) %>%
  mutate(ratingPeriod = ifelse(ratingPeriod < 0, 0, ratingPeriod))

validation <- validation %>%
  mutate(ratingDate = as.integer(year(as_datetime(timestamp)))) %>%
  mutate(movieDate = as.integer(str_sub(title, -5, -2))) %>% 
  mutate(ratingPeriod = ratingDate - movieDate) %>%
  mutate(ratingPeriod = ifelse(ratingPeriod < 0, 0, ratingPeriod))

```

### MODELING

Due to the number of movies and users, training the data set is not feasible.
Then we will build the model, according to the following formula:
$$Y = mu + b_i + b_u + b_t + b_g$$

And then we will apply regularization.





```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## GitHub Documents

This is an R Markdown format used for publishing markdown documents to GitHub. When you click the **Knit** button all R code chunks are run and a markdown file (.md) suitable for publishing to GitHub is generated.

## Including Code

You can include R code in the document as follows:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
